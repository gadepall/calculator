\documentclass[conference]{IEEEtran}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{url}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!40!black},
  stringstyle=\color{red},
  numbers=left,                     % keep numbers
  numberstyle=\scriptsize\ttfamily, % more readable numbers
  numbersep=8pt,                    % add spacing from code
  xleftmargin=1.5em,                % indent code so numbers don’t overlap
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
  showstringspaces=false,
  captionpos=b,
  keepspaces=true                   % preserve spacing properly
}

\title{Implementation of Scientific Calculator Functions on Microcontroller using C}

\author{
\IEEEauthorblockN{Krishna Patil, Nara Prajwal}
\IEEEauthorblockA{
Department of Electrical Engineering\\
IIT Hyderabad\\
Email: ee24btech11036@iith.ac.in, ee24btech11051@iith.ac.in}
}

\begin{document}

\maketitle

\begin{abstract}
This paper presents the implementation of scientific calculator functions such as trigonometric, logarithmic, exponential, power, factorial, and expression parsing using the C programming language on a microcontroller platform. Various numerical algorithms such as Runge--Kutta (RK4), series expansions, iterative methods, and parsing algorithms have been employed. Each function is discussed with its algorithmic basis followed by its C implementation.
\end{abstract}

\begin{IEEEkeywords}
Scientific Calculator, Microcontroller, Runge--Kutta Method, Quake III Algorithm, Shunting Yard Algorithm, C Programming
\end{IEEEkeywords}

\section{Introduction}
The design and implementation of a scientific calculator on microcontrollers requires efficient mathematical algorithms due to limited hardware resources. This paper demonstrates the use of numerical methods such as RK4 for solving differential equations to compute trigonometric and exponential functions, iterative methods for logarithms, the Quake III inverse square root algorithm for efficient computations, and the Shunting Yard algorithm for expression parsing.

\section{Software Implementation}

Instead of using "general expansion methods" (like Taylor/Maclaurin series with many terms), we reformulated each function as a differential equation.
 The algorithms used to calculate the values are  RK4 (for ODEs), Newton–Raphson (for refinements like inverse sqrt).

 \subsection{Supported Functions}

\begin{table}[htbp]
\centering
\caption{Supported Functions and Operations}
\label{tab:supported}
\begin{tabular}{ll}
\toprule
\textbf{Category} & \textbf{Functions / Operations} \\
\midrule
Trigonometric & $\sin(x), \cos(x), \tan(x)$ \\
Inverse Trigonometric & $\arcsin(x), \arccos(x), \arctan(x)$ \\
Exponential / Logarithmic & $e^x, \ln(x)$ \\
Power / Root & $x^y, \tfrac{1}{\sqrt{x}}$ \\
Factorial & $n!$ \\
Basic Arithmetic & $+, -, \times, \div$ \\
Constants & $\pi, e$ \\
Input Symbols & Digits $0$–$9$, decimal point, parentheses $(,)$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Runge--Kutta Method (RK4)}
The fourth-order Runge--Kutta method (\cite{grewal2014,kreyszig2011}) is a widely used numerical technique for solving ordinary differential equations of the form:
\begin{align}
\frac{dy}{dx} = f(x,y), \quad y(x_0)=y_0
\end{align}
It estimates the solution by computing weighted averages of slopes at multiple points within the interval. Given a step size $h$, the next value is computed as:
\begin{align}
y_{n+1} = y_n + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)
\end{align}
where
\begin{align}
k_1 &= h f(x_n,y_n), \\
k_2 &= h f(x_n + h/2, y_n + k_1/2), \\
k_3 &= h f(x_n + h/2, y_n + k_2/2), \\
k_4 &= h f(x_n + h, y_n + k_3).
\end{align}
This method achieves $O(h^4)$ accuracy while maintaining computational efficiency. In this work, RK4 is applied to trigonometric and exponential functions by reformulating them as differential equations (e.g., $\sin(x)$ from $y''+y=0$, $\exp(x)$ from $y'=y$).

\subsection{Trigonometric Functions}

\subsubsection{Sine Function} \\
The sine function \cite{ncert12} is computed by solving the second-order differential equation:
\begin{align}
\frac{d^2y}{dx^2} + y = 0, \quad y(0)=0, \quad y'(0)=1
\end{align}
using the fourth-order Runge--Kutta method.

System:
\begin{align}
\frac{dy}{dx}=z, \quad \frac{dz}{dx}=-y, \quad y(0)=0, \; z(0)=1
\end{align}

RK4 step values:
\begin{align}
k_1 &= h z_n, \\
l_1 &= -h y_n, \\
k_2 &= h \left(z_n+\tfrac{l_1}{2}\right), \\
l_2 &= -h \left(y_n+\tfrac{k_1}{2}\right), \\
k_3 &= h \left(z_n+\tfrac{l_2}{2}\right), \\
l_3 &= -h \left(y_n+\tfrac{k_2}{2}\right), \\
k_4 &= h(z_n+l_3), \\
l_4 &= -h(y_n+k_3), \\
y_{n+1} &= y_n+\frac{1}{6}(k_1+2k_2+2k_3+k_4), \\
z_{n+1} &= z_n+\tfrac{1}{6}(l_1+2l_2+2l_3+l_4).
\end{align}

\subsubsection{Cosine Function} \\
The cosine function \cite{ncert12} is computed by solving the second-order differential equation:
\begin{align}
\frac{d^2y}{dx^2} + y = 0, \quad y(0)=1, \quad y'(0)=0
\end{align}

The RK4 recursion is identical to the sine case, but with different initial conditions.


\subsubsection{Tangent Function} \\
Tangent \cite{ncert12} is implemented as the ratio of sine and cosine:
\begin{lstlisting}[language=C, caption={C Implementation of Tangent Function}]
double tangent(double x) {
  return sine(x)/cosine(x);
}
\end{lstlisting}

\subsection{Inverse Square Root}


\subsubsection*{Quake III Algorithm}

The method obtains an initial approximation by manipulating the IEEE~754 floating-point representation of $x$, then refines it using Newton-Raphson iterations.

\begin{enumerate}
    \item Bit manipulation with a ``magic constant'' ($0x5f3759df$) produces an initial guess $y_0$.
    \item A single Newton--Raphson iteration dramatically improves accuracy.
    \item An optional second iteration yields nearly full precision. \\
\end{enumerate} 

\subsubsection*{Newton--Raphson Refinement}

We want to approximate
\begin{align} 
y = x^{-\frac{1}{2}}.
\end{align}

Define
\begin{align}
f(y) = \frac{1}{y^2} - x, \qquad f'(y) = -\frac{2}{y^3}.
\end{align}

Applying Newton--Raphson,
\begin{align}
y_{k+1} &= y_k - \frac{f(y_k)}{f'(y_k)} \\[6pt]
        &= y_k - \frac{\tfrac{1}{y_k^2} - x}{-\tfrac{2}{y_k^3}} \\[6pt]
        &= y_k + \frac{y_k}{2}\left(1 - x y_k^2 \right) \\[6pt]
        &= y_k \left(\tfrac{3}{2} - \tfrac{1}{2} x y_k^2\right).
\end{align}

Thus one Newton iteration is simply
\begin{align}
y \;\gets\; y \left( 1.5 - 0.5 \, x \, y^2 \right).
\end{align}

\subsection{Inverse Trigonometric Functions}
\subsubsection{Arcsine} \\
The ODE for the arcsine function \cite{ncert12} is
ODE:
\begin{align}
\frac{dy}{dx} = \frac{1}{\sqrt{1-x^2}}, \quad y(0)=0
\end{align}

RK4 step values:
\begin{align}
k_1 &= \frac{h}{\sqrt{1-x_n^2}}, \\
k_2 &= \frac{h}{\sqrt{1-(x_n+h/2)^2}}, \\
k_3 &= \frac{h}{\sqrt{1-(x_n+h/2)^2}}, \\
k_4 &= \frac{h}{\sqrt{1-(x_n+h)^2}}, \\
y_{n+1} &= y_n+\frac{1}{6}(k_1+2k_2+2k_3+k_4)\\
\end{align}

\subsubsection{Arccosine} \\
 Use the identity \cite{ncert12}
\begin{align}
   \arccos(x) = \frac{\pi}{2} - \arcsin(x) 
\end{align}

\subsubsection{Arctangent} \\
The ODE for the arctan function \cite{ncert12} is
ODE:
\begin{align}
\frac{dy}{dx} = \frac{1}{1+x^2}, \quad y(0)=0
\end{align}

RK4 step values:
\begin{align}
k_1 &= \frac{h}{1+x_n^2}, \\
k_2 &= \frac{h}{1+(x_n+h/2)^2}, \\
k_3 &= \frac{h}{1+(x_n+h/2)^2}, \\
k_4 &= \frac{h}{1+(x_n+h)^2}, \\
y_{n+1} &= y_n+\tfrac{1}{6}(k_1+2k_2+2k_3+k_4).
\end{align}

\subsection{Logarithmic Functions}

The natural logarithm can be obtained by solving the differential equation \cite{ncert12}
\begin{align}
\frac{dy}{dx} = \frac{1}{x}, \quad y(1)=0
\end{align}
which has the exact solution $y(x)=\ln(x)$. Using the RK4 method, we can approximate $\ln(x)$ by integrating this ODE from $x=1$ to the target value.

RK4 step values:

\begin{align}
k_1 &= \frac{h}{x_n}, \\
k_2 &= \frac{h}{x_n+h/2}, \\
k_3 &= \frac{h}{x_n+h/2}, \\
k_4 &= \frac{h}{x_n+h}, \\
y_{n+1} &= y_n+\frac{h}{6}\left(\frac{1}{x_n}+\frac{4}{x_n+h/2}+\frac{1}{x_n+h}\right).
\end{align}

\subsection{Exponential Functions}

\subsubsection{Power Function} \\
The power function $y=x^w$ \cite{ncert12} satisfies
\begin{align}
\frac{dy}{dx} = \frac{w}{x}y, \quad y(1)=1
\end{align}

RK4 step values:

\begin{align}
k_1 &= h \cdot \frac{w}{x_n}y_n, \\
k_2 &= h \cdot \frac{w}{x_n+\tfrac{h}{2}}\left(y_n+\tfrac{k_1}{2}\right), \\
k_3 &= h \cdot \frac{w}{x_n+\tfrac{h}{2}}\left(y_n+\tfrac{k_2}{2}\right), \\
k_4 &= h \cdot \frac{w}{x_n+h}\left(y_n+k_3\right), \\
y_{n+1} &= y_n+\tfrac{1}{6}(k_1+2k_2+2k_3+k_4).
\end{align}

\subsection{$e^x$ Function}
\begin{lstlisting}[language=C, caption={C Implementation of Exponential Function}]
#define EULER_CONST 2.718281828459045

double exponential(double x_target) {

y = pow(EULER_CONST, x_target)
  }
  return y;
}
\end{lstlisting}
\subsection{Factorial Function}
\begin{lstlisting}[language=C, caption={C Implementation of Factorial Function}]
unsigned long long factorial(int n) {
  if (n==0) return 1;
  return n*factorial(n-1);
}
\end{lstlisting}

\subsection{Expression Parsing}

The Shunting Yard algorithm is employed for converting infix expressions into postfix form for evaluation.

\subsection{Overview}
The \textbf{Shunting Yard Algorithm}, proposed by Edsger Dijkstra, is a method for converting mathematical expressions in infix notation into postfix notation (Reverse Polish Notation, RPN).  
It relies on two structures:
\begin{itemize}
    \item A \textbf{stack} for operators/functions
    \item An \textbf{output queue} for the final postfix expression
\end{itemize}

\subsection{Algorithm Steps}
\begin{enumerate}
    \item Initialize an empty stack and output queue.
    \item For each token:
    \begin{enumerate}
        \item Numbers $\rightarrow$ add to output.
        \item Functions $\rightarrow$ push to stack.
        \item Operators $\rightarrow$ pop higher/equal precedence operators from stack to output (respecting associativity), then push current operator.
        \item ``('' $\rightarrow$ push to stack.
        \item ``)'' $\rightarrow$ pop to output until matching ``('' is found, discard brackets.
    \end{enumerate}
    \item After processing, pop remaining operators to output.
\end{enumerate}

\subsection{Operator Precedence}
\begin{table}[htbp]
\centering
\caption{Operator Precedence and Associativity}
\label{tab:precedence}
\begin{tabular}{lcc}
\toprule
\textbf{Operator} & \textbf{Precedence} & \textbf{Associativity} \\
\midrule
$\vee$ (power) & 4 & Right \\
$*$, $/$ & 3 & Left \\
$+$, $-$ & 2 & Left \\
\bottomrule
\end{tabular}
\end{table}
\subsection{Example}
For the expression $3 + 4 * 2 / (1 - 5)$, the Shunting Yard Algorithm yields the postfix form:
\begin{align}
3 \ 4 \ 2 \ * \ 1 \ 5 \ - \ / \ +
\end{align}

Algorithmic Steps :

\begin{table}[htbp]
\centering
\caption{Shunting Yard Example for $3 + 4 * 2 / (1 - 5)$}
\label{tab:example}
\begin{tabular}{llll}
\toprule
\textbf{Token} & \textbf{Action} & \textbf{Stack} & \textbf{Output} \\
\midrule
3 & Add to output &  & 3 \\
+ & Push to stack & + & 3 \\
4 & Add to output & + & 3 4 \\
* & Push to stack & + * & 3 4 \\
2 & Add to output & + * & 3 4 2 \\
/ & Pop *, push / & + / & 3 4 2 * \\
( & Push to stack & + / ( & 3 4 2 * \\
1 & Add to output & + / ( & 3 4 2 * 1 \\
- & Push to stack & + / ( - & 3 4 2 * 1 \\
5 & Add to output & + / ( - & 3 4 2 * 1 5 \\
) & Pop until ( & + / & 3 4 2 * 1 5 - \\
End & Pop stack &  & 3 4 2 * 1 5 - / + \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Reverse Polish Notation (RPN)}
Reverse Polish Notation, also known as postfix notation, is a way of writing mathematical expressions in which 
operators follow their operands. Unlike infix notation (e.g., $3 + 4$), RPN eliminates the need for parentheses by 
unambiguously encoding operator precedence.

\begin{itemize}
    \item Example (infix): $3 + 4$
    \item Equivalent RPN: $3 \ 4 \ +$
\end{itemize}

This simplicity makes RPN especially suitable for evaluation using a stack-based algorithm.


\subsection{Evaluating RPN}
Evaluation of RPN uses a stack:
\begin{enumerate}
    \item Scan tokens left to right.
    \item Push numbers on the stack.
    \item For operators, pop required operands, apply operation, push result.
\end{enumerate}

For the above example, evaluating the postfix expression gives the result $1$ as expected .

\subsection{Complexity and Applications}
The algorithm runs in $O(n)$ time, where $n$ is the number of tokens, since each token is processed once.  
Combined with RPN evaluation, it provides an efficient method for handling expressions in calculators, compilers, and symbolic computation systems.

\subsection{Function Handling}
The Shunting Yard Algorithm can also be used to implement functions such as $\sin(x)$, $\cos(x)$, and others. Function handling follows these rules:

\begin{enumerate}
    \item When a function token is encountered, it is pushed onto the operator stack.
    \item Arguments (possibly separated by commas) are processed as sub-expressions in the usual way.
    \item When the closing parenthesis ``)'' is reached:
    \begin{itemize}
        \item Operators are popped from the stack to the output queue until the matching ``('' is found.
        \item The function token itself is then moved from the stack to the output queue.
    \end{itemize}
\end{enumerate}

As a result, function calls are correctly represented in postfix form. For example:
\begin{align}
\sin(x) \;\;\rightarrow\;\; x \ \sin, 
\end{align}


\subsection{Conclusion}
The Shunting Yard Algorithm, together with RPN evaluation, ensures efficient parsing and evaluation of mathematical expressions. It respects operator precedence, associativity, and bracket handling, making it a cornerstone in expression processing across computing applications.

\subsection{Code Repository}
The complete C implementations of the algorithms discussed in this paper are available at: \url{https://github.com/gadepall/calculator/tree/main/codes}


\begin{lstlisting}[caption={Repository Structure in codes/}]
codes/
|-- ShuntingYard.c
|-- inv_sq_root.c
|-- inv_trig_func.c
|-- log.c
|-- power_func.c
|-- trig_func.c
\end{lstlisting}

\section{Hardware Implementation}

\begin{thebibliography}{00}

\bibitem{grewal2014}
B. S. Grewal, \textit{Higher Engineering Mathematics}, 43rd ed. New Delhi, India: Khanna Publishers, 2014.

\bibitem{kreyszig2011}
E. Kreyszig, \textit{Advanced Engineering Mathematics}, 10th ed. Hoboken, NJ, USA: John Wiley \& Sons, 2011.

\bibitem{ncert12}
National Council of Educational Research and Training (NCERT), 
\textit{Mathematics: Textbook for Class XII}, Part 1 and 2, New Delhi, India: NCERT, 2006.

\end{thebibliography}




\end{document}
